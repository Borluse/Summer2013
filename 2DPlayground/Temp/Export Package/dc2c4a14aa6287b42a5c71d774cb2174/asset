using UnityEngine;
using UnityEditor;
using System;
using System.Collections;
using System.Collections.Generic;

public class LevelSettings : MonoBehaviour {
	public const string SPAWNER_CONTAINER_TRANS_NAME = "Spawners";
	public const string PREFAB_POOLS_CONTAINER_TRANS_NAME = "PrefabPools";
	public const string REVERT_LEVEL_SETTINGS_ALERT = "Please revert your LevelSettings prefab.";
	public const string NO_SPAWN_CONTAINER_ALERT = "You have no '" + SPAWNER_CONTAINER_TRANS_NAME + "' prefab under LevelSettings. " + REVERT_LEVEL_SETTINGS_ALERT;
	public const string NO_PREFAB_POOLS_CONTAINER_ALERT = "You have no '" + PREFAB_POOLS_CONTAINER_TRANS_NAME + "' prefab under LevelSettings.";

	private const float WAVE_CHECK_INTERVAL = .3f; // reduce this to check for spawner activations more often. This is set to 2x a second.
	
	public Texture logoTexture;
	public Transform RedSpawnerTrans;
	public Transform GreenSpawnerTrans;
	public Transform PrefabPoolTrans;
	public string newSpawnerName = "spawnerName";
	public string newPrefabPoolName = "EnemiesPool";
	public SpawnerType newSpawnerType = SpawnerType.Green;
	public LevelWaveMusicSettings gameOverMusicSettings = new LevelWaveMusicSettings();
	
	
	public bool levelsAreExpanded = true;
	public bool createSpawnersExpanded = true;
	public bool createPrefabPoolsExpanded = true;
	
	public bool disableSyncroSpawners = false;
	public bool isLoggingOn = false;
	public List<LevelSpecifics> LevelTimes = new List<LevelSpecifics>();
	//public bool 
	
	private List<WaveSyncroPrefabSpawner> syncroSpawners = new List<WaveSyncroPrefabSpawner>();
	private static Dictionary<int, List<LevelWave>> waveSettingsByLevel;
	private static int currentLevel;
	private static int currentLevelWave;
	private static bool gameIsOver;
	private static bool statIsLoggingOn;
	private bool isValid;
	private float lastWaveChangeTime;
	private bool hasFirstWaveBeenStarted;
	private static LevelWave previousWave;
	private static List<int> eliminationSpawnersUnkilled = new List<int>();
	
	public enum WaveMusicMode {
		KeepPreviousMusic,
		PlayNew,
		Silence
	}
	
	public enum WaveType {
		Timed,
		Elimination
	}
	
	public enum SpawnerType {
		Green,
		Red
	}
	
	void Awake() {
		hasFirstWaveBeenStarted = false;
		isValid = true;
		int iLevel = 0;		
		currentLevel = 0;
		currentLevelWave = 0;
		statIsLoggingOn = isLoggingOn;
		previousWave = null;
		
		if (LevelTimes.Count == 0) {
			Debug.LogError("NO LEVEL / WAVE TIMES DEFINED. ABORTING.");
			isValid = false;
			return;
		} else if (LevelTimes[0].WaveSettings.Count == 0) {
			Debug.LogError("NO LEVEL 1 / WAVE 1 TIME DEFINED! ABORTING.");
			isValid = false;
			return;
		}
		
		var levelSettingScripts = GameObject.FindObjectsOfType(typeof(LevelSettings));
		if (levelSettingScripts.Length > 1) {
			Debug.LogError("You have more than one LevelWaveSettings prefab in your scene. Please delete all but one. Aborting.");
			isValid = false;
			return;
		}
		
		waveSettingsByLevel = new Dictionary<int, List<LevelWave>>();
		
		var waveLs = new List<LevelWave>();
		
		for (var i = 0; i < LevelTimes.Count; i++) {
			var level = LevelTimes[i];
			
			if (level.WaveSettings.Count == 0) {
				Debug.LogError("NO WAVES DEFINED FOR LEVEL: " + (iLevel + 1));
				isValid = false;
				continue;
			}
			
			waveLs = new List<LevelWave>();
			LevelWave newLevelWave = null;
			
			foreach (var waveSetting in level.WaveSettings) {
				if (waveSetting.WaveDuration <= 0) {
					Debug.LogError("WAVE DURATION CANNOT BE ZERO OR LESS - OCCURRED IN LEVEL " + (i + 1) + ".");
					isValid = false;
					return;
				}
				
				newLevelWave = new LevelWave() {
					waveType = waveSetting.waveType,
					WaveDuration = waveSetting.WaveDuration,
					musicSettings = new LevelWaveMusicSettings() {
						WaveMusicMode = waveSetting.musicSettings.WaveMusicMode,
						WaveMusic = waveSetting.musicSettings.WaveMusic,
						FadeTime = waveSetting.musicSettings.FadeTime
					}
				};
				
				if (waveSetting.waveType == WaveType.Elimination) {
					newLevelWave.WaveDuration = 500; // super long to recognize this problem if it occurs.
				}
				
				waveLs.Add(newLevelWave);
			}
			
			if (i == LevelTimes.Count - 1) { // extra bogus wave so that the real last wave will get run
				newLevelWave = new LevelWave() {
					musicSettings = new LevelWaveMusicSettings() {
						WaveMusicMode = WaveMusicMode.KeepPreviousMusic,
						WaveMusic = null
					},
					WaveDuration = 1
				};
				
				waveLs.Add(newLevelWave);
			}
			
			waveSettingsByLevel.Add(iLevel, waveLs);
			
			//Debug.LogError("w: " + waveSettingsByLevel.Count);
			//Debug.LogError(iLevel + " : " + waveSettingsByLevel[iLevel][0].WaveDuration + ", " + waveSettingsByLevel[iLevel][1].WaveDuration + ", " + waveSettingsByLevel[iLevel][2].WaveDuration + ", " + waveSettingsByLevel[iLevel][3].WaveDuration);
			iLevel++;
		}
		
		WaveSyncroPrefabSpawner spawner = null;
		
		foreach (var gObj in GetAllSpawners()) {
			spawner = gObj.GetComponent<WaveSyncroPrefabSpawner>();
			
			syncroSpawners.Add(spawner);
		}
		
		//Debug.LogError("spawners: " + syncroSpawners.Count);
		gameIsOver = false;
	}
	
	void Start() {
		if (isValid) {
			WaveMusicChanger.SetInitialMusic(this.LevelTimes[0].WaveSettings[0]);
			StartCoroutine(this.CoStart());
		}
	}
	
	IEnumerator CoStart() {
    	while (true) {
        	yield return StartCoroutine(this.CoUpdate());
		}
	}
	
	IEnumerator CoUpdate() {
		yield return new WaitForSeconds(WAVE_CHECK_INTERVAL);
		
		if (gameIsOver) {
			return true;
		}
		
		var waveInfo = CurrentWaveInfo;
		var prevWaveInfo = previousWave;
		WaveType waveType;
		
		int timeToCompare = 0;
		
		if (prevWaveInfo != null) {
			timeToCompare = previousWave.WaveDuration;
			waveType = previousWave.waveType;
		} else {
			timeToCompare = waveInfo.WaveDuration;
			waveType = waveInfo.waveType;
		}
		
		//check if level or wave is done.
		if (hasFirstWaveBeenStarted) {
			switch (waveType) {
				case WaveType.Timed:
					if (Time.time - this.lastWaveChangeTime < timeToCompare) {
						return true;
					}
					break;
				case WaveType.Elimination:
					if (eliminationSpawnersUnkilled.Count > 0) {
						return true;
					}
					break;
			}
		}
		
		if (!disableSyncroSpawners) {
			// notify all synchro spawners
			eliminationSpawnersUnkilled.Clear();
			
			foreach(var syncro in syncroSpawners) {
				if (!syncro.WaveChange()) { // returns true if wave found.
					continue;
				}
				
				if (waveInfo.waveType == WaveType.Elimination) {
					eliminationSpawnersUnkilled.Add(syncro.GetInstanceID());
				}
			}
		}
		
		LevelWaveMusicSettings musicSpec = null;
		
		// change music maybe
		if (currentLevel > 0 && currentLevelWave == 0) {
			if (isLoggingOn) {
				Debug.Log("Level up - new level# is: " + (currentLevel + 1) + " . Wave 1 starting, occurred at time: " + Time.time);
			}
			
			musicSpec = waveInfo.musicSettings;
		} else if (currentLevel > 0 || currentLevelWave > 0) {
			if (isLoggingOn) {
				Debug.Log("Wave up - new wave# is: " + (currentLevelWave + 1) + " on Level: " + (currentLevel + 1) + ". Occured at time: " + Time.time);
			}

			musicSpec = waveInfo.musicSettings;
		}
		
		previousWave = CurrentWaveInfo;
		currentLevelWave++;
		
		if (currentLevelWave >= WaveLengths.Count) {
			//Debug.Log("level over");
			currentLevelWave = 0;
			currentLevel++;
			
			if (!gameIsOver && currentLevel >= waveSettingsByLevel.Count)  {
				gameIsOver = true;
				
				musicSpec = gameOverMusicSettings;
				Win();
				
				// trigger "win" code if you wish here. Remove this if you like, this is just for you to easily find.
				Debug.Log("All waves / levels complete. Occured at time: " + Time.time);
			}
		}
		
		if (musicSpec != null) {
			WaveMusicChanger.WaveUp(musicSpec);
		}
		
		lastWaveChangeTime = Time.time;
		hasFirstWaveBeenStarted = true;
	}
	
	void OnApplicationQuit() {
		SpawnUtility.AppIsShuttingDown = true; // very important!!
	}
	
	private void Win() {
		// this is for you to add code for your game!
	}
	
	public List<Transform> GetAllSpawners() {
		var spawnContainer = this.transform.FindChild(SPAWNER_CONTAINER_TRANS_NAME);
		
		if (spawnContainer == null) {
			Debug.LogError(NO_SPAWN_CONTAINER_ALERT);
			return null;
		}
		
		var spawners = new List<Transform>();
		for (var i = 0; i < spawnContainer.childCount; i++) {
			spawners.Add(spawnContainer.GetChild(i));
		}
		
		return spawners;
	}
	
	#region Properties
	public static int LastLevel {
		get {
			return waveSettingsByLevel.Count;
		}
	}
	
	public static int CurrentLevelWave {
		get {
			return currentLevelWave;
		}
	}
	
	public static int CurrentLevel {
		get {
			return currentLevel;
		}
	}
	
	public static int CurrentWaveLength {
		get {
			return 0;
		}
	}
	
	public static List<LevelWave> WaveLengths {
		get {
			return  waveSettingsByLevel[currentLevel];
		}
	}
	
	public static LevelWave CurrentWaveInfo {
		get {
			var waveInfo = WaveLengths[currentLevelWave];
			return waveInfo;
		}
	}
	
	public static LevelWave PreviousWaveInfo {
		get {
			return previousWave;
		}
	}
	
	public static bool IsLoggingOn {
		get {
			return statIsLoggingOn;
		}
	}
	
	public static bool IsGameOver {
		get {
			return gameIsOver;
		}
		set {
			gameIsOver = value;
		}
	}
	
	public static void EliminationSpawnerCompleted(int instanceId) {
		eliminationSpawnersUnkilled.Remove(instanceId);
	}
	#endregion
}
