using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System;

public class WaveSyncroPrefabSpawner : MonoBehaviour {
	private const float ELIMINATION_CHECK_INTERVAL = .2f; // reduce this to check for spawner activations more often. This is set to 2x a second.
	
	public Texture logoTexture;
	public List<WaveSpecifics> waveSpecs = new List<WaveSpecifics>();
	public bool isExpanded = true;
	public bool isEnabled = true;
	
	private int currentWaveSize;
	private bool waveFinishedSpawning;
	private int countSpawned;
	private float singleSpawnTime;
	private float lastSpawnTime;
	private WaveSpecifics currentWave;
	private float waveStartTime;
	private Transform trans;
	private List<Transform> spawnedWaveMembers = new List<Transform>();
	private float? repeatTimer;
	private float repeatWaitTime;
	private int waveRepetitionNumber;
	private bool spawnerValid;
	private WavePrefabPool wavePool = null;
	
	// Use this for initialization
	void Awake () {
		this.trans = this.transform;
		this.waveFinishedSpawning = true;
		this.repeatTimer = null;
		this.spawnerValid = true;
		this.waveRepetitionNumber = 0;
		
		this.CheckForDuplicateWaveLevelSettings();
	}
	
	private void CheckForDuplicateWaveLevelSettings() {
		var waveLevelCombos = new List<string>();
		foreach (var wave in waveSpecs) {
			var combo = wave.SpawnLevelNumber + ":" + wave.SpawnWaveNumber;
			if (waveLevelCombos.Contains(combo)) {
				Debug.LogError(string.Format("Spawner '{0}' contains more than one wave setting for level: {1} and wave: {2}. Spawner aborting until this is fixed.",
					this.name, 
					wave.SpawnLevelNumber + 1, 
					wave.SpawnWaveNumber + 1
					));
				this.spawnerValid = false;
				
				break;
			}
			
			waveLevelCombos.Add(combo);
		}
	}
	
	void Start() {
		if (this.spawnerValid) {
			StartCoroutine(this.CoStart());
		}
	}
	
	IEnumerator CoStart() {
    	while (true) {
        	yield return StartCoroutine(this.CoUpdate());
		}
	}
	
	IEnumerator CoUpdate() {
		yield return new WaitForSeconds(ELIMINATION_CHECK_INTERVAL);
		
		if (LevelSettings.IsGameOver || this.currentWave == null || !this.spawnerValid || !this.waveFinishedSpawning || !currentWave.IsValid) {
			return true;
		}

		// wait for next wave.
		var hasNoneLeft = !SpawnUtility.HasActiveMember(this.spawnedWaveMembers);
		
		if (hasNoneLeft) {
			//Debug.Log("none: " + LevelSettings.PreviousWaveInfo.waveType);
			if (LevelSettings.PreviousWaveInfo.waveType == LevelSettings.WaveType.Elimination && (waveRepetitionNumber + 1 >= currentWave.repetitions || !currentWave.repeatWaveUntilNew)) {
				//Debug.Log("elim");
				LevelSettings.EliminationSpawnerCompleted(this.GetInstanceID());
			} else if (currentWave.repeatWaveUntilNew) {
				if (!this.repeatTimer.HasValue) {
					this.repeatTimer = Time.time;
					this.repeatWaitTime = UnityEngine.Random.Range(this.currentWave.repeatPauseMin, this.currentWave.repeatPauseMax);
				} else if (Time.time - this.repeatTimer.Value > this.repeatWaitTime) {
					waveRepetitionNumber++;
					//Debug.Log("wave rep: " + waveRepetitionNumber);
	
					WaveRepeat();
				}
			}
		}
	}
	
	public bool WaveChange() {
		if (!this.spawnerValid) {
			return false;
		}
		
		return SetupNextWave(true);
	}
	
	public void WaveRepeat() {
		SetupNextWave(false);
	}
	
	void FixedUpdate() {
		if (LevelSettings.IsGameOver || this.currentWave == null || !this.spawnerValid) {
			return;
		}
		
		if (this.waveFinishedSpawning 
			|| (Time.time - this.waveStartTime < this.currentWave.WaveDelaySeconds)
			|| (Time.time - this.lastSpawnTime <= this.singleSpawnTime && this.singleSpawnTime > Time.deltaTime)) {
			
			return;
		}
		
		int numberToSpawn = 1;
		if (this.singleSpawnTime < Time.deltaTime) {
			if (this.singleSpawnTime == 0) {
				numberToSpawn = currentWaveSize;
			} else {
				numberToSpawn = (int) Math.Ceiling(Time.deltaTime / this.singleSpawnTime);
			}
		}
		
		for (var i = 0; i < numberToSpawn; i++) {
			if (this.CanSpawnOne()) {
				Transform prefabToSpawn = this.GetSpawnable(this.currentWave);		
				if (prefabToSpawn == null) {
					Debug.LogError(string.Format("Spawner '{0}' has no prefab to spawn for wave# {1} on level# {2}.", 
						this.name, 
						this.currentWave.SpawnWaveNumber + 1,
						this.currentWave.SpawnLevelNumber + 1));
		
					this.spawnerValid = false;
					return;
				}
		
				var spawnPosition = this.GetSpawnPosition(this.trans.position, this.countSpawned);
				
				var spawnedPrefab = SpawnUtility.Spawn(prefabToSpawn, 
					spawnPosition, this.GetSpawnRotation(prefabToSpawn, this.countSpawned));
			
				if (spawnedPrefab == null) {
					Debug.Log("Could not spawn: " + prefabToSpawn + " : " + Time.time);
					return;
				}
				
				this.AfterSpawn(spawnedPrefab);
				if (currentWave.repeatWaveUntilNew || LevelSettings.PreviousWaveInfo.waveType == LevelSettings.WaveType.Elimination) {
					this.spawnedWaveMembers.Add(spawnedPrefab);
				}
			}
				
			this.countSpawned++;
			
			if (this.countSpawned >= currentWaveSize) {
				if (LevelSettings.IsLoggingOn) {
					Debug.Log(string.Format("Spawner '{0}' finished spawning wave# {1} on level# {2}.",
						this.name,
						this.currentWave.SpawnWaveNumber + 1,
						this.currentWave.SpawnLevelNumber + 1));
				}
				this.waveFinishedSpawning = true;
			}
			
			this.lastSpawnTime = Time.time;
		}
	}
	
	protected virtual Vector3 GetSpawnPosition(Vector3 pos, int itemSpawnedIndex) {
		var addVector = Vector3.zero;

		if (this.currentWave.enableRandomizations) {
			addVector.x = UnityEngine.Random.Range(-currentWave.randomDistanceX, currentWave.randomDistanceX);
			addVector.y = UnityEngine.Random.Range(-currentWave.randomDistanceY, currentWave.randomDistanceY);
			addVector.z = UnityEngine.Random.Range(-currentWave.randomDistanceZ, currentWave.randomDistanceZ);
		}
		
		if (this.currentWave.enableIncrements && itemSpawnedIndex > 0) {
			addVector.x += (currentWave.incrementPosX * itemSpawnedIndex);
			addVector.y += (currentWave.incrementPosY * itemSpawnedIndex);
			addVector.z += (currentWave.incrementPosZ * itemSpawnedIndex);
		}
		
		return pos + addVector;
	}
	
	protected virtual Quaternion GetSpawnRotation(Transform prefabToSpawn, int itemSpawnedIndex) {
		Vector3 euler = prefabToSpawn.rotation.eulerAngles;

		if (this.currentWave.enableRandomizations && this.currentWave.randomXRotation) {
			euler.x = UnityEngine.Random.Range(0f, 360f);			
		} else if (this.currentWave.enableIncrements && itemSpawnedIndex > 0) {
			euler.x += (itemSpawnedIndex * this.currentWave.incrementRotationX);
		}
		
		if (this.currentWave.enableRandomizations && this.currentWave.randomYRotation) {
				euler.y = UnityEngine.Random.Range(0f, 360f);			
		} else if (this.currentWave.enableIncrements && itemSpawnedIndex > 0) {
			euler.y += (itemSpawnedIndex * this.currentWave.incrementRotationY);
		}
		
		if (this.currentWave.enableRandomizations &&  this.currentWave.randomZRotation) {
			euler.z = UnityEngine.Random.Range(0f, 360f);			
		} else if (this.currentWave.enableIncrements && itemSpawnedIndex > 0) {
			euler.z += (itemSpawnedIndex * this.currentWave.incrementRotationZ);
		}

		return Quaternion.Euler(euler);
	}
	
	protected virtual void AfterSpawn(Transform spawnedTrans) {
		if (this.currentWave.enablePostSpawnNudge) {
			spawnedTrans.Translate(Vector3.forward * this.currentWave.postSpawnNudgeForward);
			spawnedTrans.Translate(Vector3.right * this.currentWave.postSpawnNudgeRight);
			spawnedTrans.Translate(Vector3.down * this.currentWave.postSpawnNudgeDown);
		}
	}
	
	protected virtual bool CanSpawnOne() {
		return true; // this is for later subclasses to override (or ones you make!)
	}
	
	public bool IsUsingPrefabPool(Transform poolTrans) {
		foreach (var _wave in this.waveSpecs) {
			if (_wave.spawnSource == WaveSpecifics.SpawnOrigin.PrefabPool && _wave.prefabPoolTrans == poolTrans) {
				return true;
			}
		}
		
		return false;
	}
	
	public WaveSpecifics FindWave(int levelToMatch, int waveToMatch) {
		foreach (var _wave in this.waveSpecs) {
			if (_wave.SpawnLevelNumber != levelToMatch || _wave.SpawnWaveNumber != waveToMatch) {
				continue;
			}
			
			// found the match, get outa here!!
			return _wave;
		}
		
		return null;
	}
	
	private void LogAdjustments(int adjustments) {
		if (adjustments > 0) {
			Debug.Log(string.Format("Adjusted {0} wave(s) in spawner '{1}' to match new Level/Wave numbers", adjustments, this.name));
		}
	}
	
	public void DeleteLevel(int level) {
		var deadWaves = new List<WaveSpecifics>();
		
		foreach (var wrongWave in this.waveSpecs) {
			if (wrongWave.SpawnLevelNumber == level) {
				deadWaves.Add(wrongWave);
			}
		}
		
		foreach (var dead in deadWaves) {
			this.waveSpecs.Remove(dead);
		}
		
		if (deadWaves.Count > 0) {
			Debug.Log(string.Format("Deleted {0} matching wave(s) in spawner '{1}'", deadWaves.Count, this.name));
		}

		int adjusted = 0;
		foreach (var wrongWave in this.waveSpecs) {
			if (wrongWave.SpawnLevelNumber > level) {
				wrongWave.SpawnLevelNumber--;
				adjusted++;
			}
		}
		
		LogAdjustments(adjusted);
	}
	
	public void InsertLevel(int level) {
		int adjustments = 0;
 		
		foreach (var wrongWave in this.waveSpecs) {
			if (wrongWave.SpawnLevelNumber >= level) {
				wrongWave.SpawnLevelNumber++;
				adjustments++;
			}
		}
		
		LogAdjustments(adjustments);
	}
	
	public void InsertWave(int newWaveNumber, int level) {
		int adjustments = 0;
		
		foreach (var wrongWave in this.waveSpecs) {
			if (wrongWave.SpawnLevelNumber == level && wrongWave.SpawnWaveNumber >= newWaveNumber) {
				wrongWave.SpawnWaveNumber++;
				adjustments++;
			}
		}
		
		LogAdjustments(adjustments);
	}
	
	public void DeleteWave(int level, int wav) {
		var matchingWave = FindWave(level, wav);
		if (matchingWave != null) {
			this.waveSpecs.Remove(matchingWave);
			Debug.Log(string.Format("Deleted matching wave in spawner '{0}'", this.name));
		}
		
		int adjustments = 0;
		
		// move same level, higher waves back one.
		foreach (var wrongWave in this.waveSpecs) {
			if (wrongWave.SpawnLevelNumber == level && wrongWave.SpawnWaveNumber > wav) {
				wrongWave.SpawnWaveNumber--;
				adjustments++;
			}
		}
		
		LogAdjustments(adjustments);
	}
	
	private bool SetupNextWave(bool scanForWave) {
		this.repeatTimer = null;
		
		if (!this.isEnabled) { // even in repeating waves.
			return false;
		}
		
		if (scanForWave) {
			// find wave
			this.currentWave = FindWave(LevelSettings.CurrentLevel, LevelSettings.CurrentLevelWave);
		
			// validate for all things that could go wrong!
			if (currentWave == null || !currentWave.enableWave) {
				return false;
			}
			
			if (currentWave.MinToSpawn == 0 || currentWave.MaxToSpawn == 0){
				return false;	
			}
			
			if (scanForWave && currentWave.WaveDelaySeconds + currentWave.TimeToSpawnWholeWave >= LevelSettings.CurrentWaveInfo.WaveDuration && LevelSettings.CurrentWaveInfo.waveType == LevelSettings.WaveType.Timed) {
				Debug.LogError(string.Format("Wave TimeToSpawnWholeWave plus Wave DelaySeconds must be less than the current LevelSettings wave duration, occured in spawner: {0}, wave# {1}, level {2}.",
					this.name, 
					currentWave.SpawnWaveNumber + 1, 
					currentWave.SpawnLevelNumber + 1));
				return false;
			}
			
			if (currentWave.MinToSpawn > currentWave.MaxToSpawn) {
				Debug.LogError(string.Format("Wave MinToSpawn cannot be greater than Wave MaxToSpawn, occured in spawner: {0}, wave# {1}, level {2}.", 
					this.name, 
					currentWave.SpawnWaveNumber + 1, 
					currentWave.SpawnLevelNumber + 1));
				return false;
			}
			
			if (currentWave.repeatWaveUntilNew && currentWave.repeatPauseMin > currentWave.repeatPauseMax) {
				Debug.LogError(string.Format("Wave Repeat Pause Min cannot be greater than Wave Repeat Pause Max, occurred in spawner: {0}, wave# {1}, level {2}.",
					this.name,
					currentWave.SpawnWaveNumber + 1,
					currentWave.SpawnLevelNumber + 1));
				return false;
			}
		}

		if (LevelSettings.IsLoggingOn) {
			Debug.Log(string.Format("{0} matching wave from spawner: {1}, wave# {2}, level {3}.",
				scanForWave ? "Starting" : "Repeating",
				this.name,
				this.currentWave.SpawnWaveNumber + 1,
				this.currentWave.SpawnLevelNumber + 1));
		}
		
		if (this.currentWave.spawnSource == WaveSpecifics.SpawnOrigin.PrefabPool) {
			var poolTrans = this.currentWave.prefabPoolTrans;
			if (poolTrans == null) {
				Debug.LogError(string.Format("Spawner '{0}' wave# {1}, level {2} is trying to use a Prefab Pool that can't be found.", 
					this.name,
					currentWave.SpawnWaveNumber + 1,
					currentWave.SpawnLevelNumber + 1));
				spawnerValid = false;
				return false;
			}
			
			wavePool = poolTrans.GetComponent<WavePrefabPool>();
		} else {
			wavePool = null;
		}
		
		this.spawnedWaveMembers.Clear();
		
		this.currentWaveSize = UnityEngine.Random.Range(currentWave.MinToSpawn, currentWave.MaxToSpawn);
		if (scanForWave) { // not on wave repeat!
			this.waveRepetitionNumber = 0;
		}
		
		this.waveStartTime = Time.time;
		this.waveFinishedSpawning = false;
		this.countSpawned = 0;
		this.singleSpawnTime = (float) currentWave.TimeToSpawnWholeWave / (float) this.currentWaveSize;
		
		return true;
	}
	
	protected virtual Transform GetSpawnable(WaveSpecifics wave) {	
		switch (wave.spawnSource) {
			case WaveSpecifics.SpawnOrigin.Specific:
				return wave.prefabToSpawn;
			case WaveSpecifics.SpawnOrigin.PrefabPool:			
				return wavePool.GetRandomWeightedTransform();
		}
		
		return null;
	}
}
